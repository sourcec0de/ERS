{"ts":1364021936649,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1364022007915,"patch":[[{"diffs":[[1,"/**\r\n * Module dependencies.\r\n */\r\n\r\nvar crypto = require('crypto');\r\n\r\n/**\r\n * Bytesize.\r\n */\r\n\r\nvar len = 128;\r\n\r\n/**\r\n * Iterations. ~300ms\r\n */\r\n\r\nvar iterations = 12000;\r\n\r\n/**\r\n * Hashes a password with optional `salt`, otherwise\r\n * generate a salt for `pass` and invoke `fn(err, salt, hash)`.\r\n *\r\n * @param {String} password to hash\r\n * @param {String} optional salt\r\n * @param {Function} callback\r\n * @api public\r\n */\r\n\r\nexports.hash = function (pwd, salt, fn) {\r\n  if (3 == arguments.length) {\r\n    crypto.pbkdf2(pwd, salt, iterations, len, fn);\r\n  } else {\r\n    fn = salt;\r\n    crypto.randomBytes(len, function(err, salt){\r\n      if (err) return fn(err);\r\n      salt = salt.toString('base64');\r\n      crypto.pbkdf2(pwd, salt, iterations, len, function(err, hash){\r\n        if (err) return fn(err);\r\n        fn(null, salt, hash);\r\n      });\r\n    });\r\n  }\r\n};"]],"start1":0,"start2":0,"length1":0,"length2":869}]],"length":869,"saved":false}
{"ts":1364022135895,"patch":[[{"diffs":[[0,". ~300ms"],[1," = iterations -> (12000) / 40\r\n * Estimated Time to Hash"],[0,"\r\n */\r\n\r"]],"start1":134,"start2":134,"length1":16,"length2":72}]],"length":925,"saved":false}
